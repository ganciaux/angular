frameworks: Cadre de travail : travailler de maniÃ¨re plus efficace et de faÃ§on plus organisÃ©e: standardiser une maniÃ¨re de dÃ©velopper des opÃ©rations rÃ©currentes dans un projet, entre plusieurs dÃ©veloppeurs

application web: Single Page Application: SPA: simple page HTML, qui contient suffisamment de JavaScript pour pouvoir fonctionner en autonomie une fois que le serveur lâ€™a envoyÃ© au client.
 - incroyablement plus rÃ©actif: pas Ã  recharger toute la page, remplacez le dÃ©lai dâ€™une requÃªte au serveur par un traitement JavaScript
 
Angular est un framework orientÃ© composant

Node.js permet dâ€™exÃ©cuter du code JavaScript cÃ´tÃ© serveur.

Npm permet dâ€™installer et gÃ©rer les dÃ©pendances de paquets JavaScript

npm install <nom_du_paquet>@<version>

composant Angular doit au minimum importer lâ€™annotation @Component.

Le mot-clef export permet de rendre le composant accessible pour dâ€™autres fichiers

lâ€™interpolation nous permet dâ€™afficher du contenu dynamiquement Ã  lâ€™utilisateur, car dÃ¨s que la valeur de la variable title sera modifiÃ©e, le template sera automatiquement mis Ã  jour

firebase login
firebase login --reauth
firebase init

ng serve --open.
ng build
firebase deploy

DÃ©finir un Ã©tat : On dÃ©finit un Ã©tat pour le composant grÃ¢ce Ã  des propriÃ©tÃ©s. On parle de â€œStateâ€ du composant
Afficher lâ€™Ã©tat : Dans le template du composant, on va dÃ©terminer les donnÃ©es du composant Ã  afficher Ã  lâ€™utilisateur.  (binding)

ImplÃ©menter un systÃ¨me de rÃ©activitÃ© pour que le template dâ€™une application web se mette Ã  jour: La rÃ©activitÃ© est simplement un mÃ©canisme qui permet Ã  l'interface utilisateur de se mettre Ã  jour automatiquement en fonction des changements de donnÃ©es.

Une rÃ©activitÃ© â€œValue basedâ€ : dirty-checking: ous les nÅ“uds du DOM (Contenu dâ€™une page HTML) sont parcourus et chaque variable affichÃ©e dans la vue Ã  lâ€™utilisateur est vÃ©rifiÃ©e. Si la valeur de cette variable a changÃ© depuis le prÃ©cÃ©dent parcours, son nÅ“ud du DOM associÃ© sera marquÃ© comme â€œDirtyâ€
La rÃ©activitÃ© â€œObservable-basedâ€ : Les Observables dÃ©finissent des flux de valeurs dans le temps, qui permettent aux frameworks de connaÃ®tre en temps rÃ©el toute modification qui pourrait survenir.
La rÃ©activitÃ© â€œSignals-basedâ€ : rÃ©active primitive.

Un signal est essentiellement un conteneur pour une valeur, qui peut changer au fil du temps. Lorsque cette valeur change, le signal Ã©met une nouvelle valeur, qui est alors propagÃ©e Ã  tous les endroits de votre application qui Ã©coutent ce signal

La fonction computed permet de crÃ©er un signal dÃ©rivÃ© Ã  partir d'un ou plusieurs autres signals. Ce nouveau signal est en lecture seule (readonly) et sa valeur est calculÃ©e automatiquement Ã  partir des signals dont il dÃ©pend. Chaque fois que l'un des signals sources change, le signal dÃ©rivÃ© est recalculÃ©.
La fonction effect Ã©couter les changements d'un signal et exÃ©cuter un code spÃ©cifique Ã  ce moment-lÃ 

1. Liaison de propriÃ©tÃ©
On utilise les crochets pour lier directement la source de lâ€™image Ã  la propriÃ©tÃ© imageUrl du composant.
<img [src]="imageUrl" />


2. Liaison dâ€™attribut
On lie lâ€™attribut for de la balise <label> Ã  la propriÃ©tÃ© de notre composant name.
<label [attr.for]="name">...</label>


3. Liaison de classe
Ajoute ou retire dynamiquement la classe special Ã  lâ€™Ã©lÃ©ment <div>, en fonction de la condition isSpecial dÃ©finie dans le composant. Cela peut Ãªtre utile pour mettre en place certaines rÃ¨gles de style par exemple.
<div [class.special]="isSpecial">Special</div>


4. Liaison de style
On peut Ã©galement dÃ©finir un style de maniÃ¨re dynamique. On dÃ©finit la couleur de notre bouton en fonction de la propriÃ©tÃ© color du composant. Cependant, il est rare dâ€™utiliser le composant et le template pour dÃ©finir des rÃ¨gles de style. On passera plutÃ´t par le fichier dÃ©diÃ© dâ€™un composant Angular xyz.component.css.
<button [style.color]="color">Join</button>

une directive est une classe Angular qui ressemble beaucoup Ã  un composant, sauf quâ€™elle nâ€™a pas de template @Directive
Lorsque Angular trouve une directive dans un template HTML, il instancie la classe de la directive correspondante et donne Ã  cette instance le contrÃ´le sur la portion du DOM qui lui revient.
Les composants
Les directives dâ€™attributs : Elles peuvent modifier le comportement des Ã©lÃ©ments HTML, des attributs, des propriÃ©tÃ©s et des composants
Les directives structurelles : ces directives sont responsables de mettre en forme une certaine disposition dâ€™Ã©lÃ©ments HTML, en ajoutant, retirant ou manipulant des Ã©lÃ©ments et leur fils

ElementRef pour accÃ©der Ã  l'Ã©lÃ©ment DOM natif.
Renderer2 pour manipuler le DOM de maniÃ¨re sÃ»re.
ViewContainerRef pour manipuler les vues.
TemplateRef pour travailler avec des templates.

Service: @Injectable permet dâ€™indiquer Ã  Angular que ce service peut lui-mÃªme avoir dâ€™autres dÃ©pendances et quâ€™il peut Ãªtre injectÃ© dans dâ€™autres parties de lâ€™application pour pouvoir Ãªtre utilisÃ© ailleurs
providedIn: root, indiquer Ã  Angular que ce sera la mÃªme instance du service qui sera fournie Ã  travers toute lâ€™application
Constructeur : La mÃ©thode la plus courante. Utiliser private dans le constructeur pour injecter le service.
Providers : DÃ©finir le service dans le tableau providers d'un composant pour crÃ©er une instance unique.
@Inject() : UtilisÃ© pour des scÃ©narios spÃ©cifiques, surtout avec des tokens.
inject() : Nouvelle mÃ©thode d'injection introduite dans Angular 14, permettant d'injecter des services dans des mÃ©thodes.

Lâ€™injection de dÃ©pendances est un modÃ¨le de dÃ©veloppement (ou design pattern pour nos amis anglo-saxons), dans lequel chaque classe reÃ§oit ses dÃ©pendances dâ€™une source externe plutÃ´t quâ€™en les crÃ©ant elle-mÃªme.

On ne gÃ¨re jamais nous-mÃªmes les dÃ©pendances dâ€™un composant ou dâ€™un service. Il faut toujours passer par le mÃ©canisme dâ€™injection de dÃ©pendances proposÃ© par Angular.

L'utilisation de RouterLink au lieu de href est recommandÃ©e dans une application Angular, car cela permet Ã  Angular de gÃ©rer la navigation en interne, ce qui amÃ©liore les performances et Ã©vite le rechargement complet de la page. 
RouterLink permet de bÃ©nÃ©ficier de fonctionnalitÃ©s avancÃ©es de navigation proposÃ©es par Angular, comme les Guards et les Resolvers
- Sans le slash ("/"), le chemin est relatif Ã  la route actuelle.
- Avec le slash ("/"), le chemin est absolu et part de la racine de l'application.

Angular simule la navigation de lâ€™utilisateur auprÃ¨s du navigateur

relier le formulaire HTML au formulaire pilotÃ© par le modÃ¨le dÃ©fini dans le composant TypeScript: <form [formGroup]="form">
la directive formControlName pour relier un champ du formulaire avec une instance de FormControl

[disabled]="pokemonLife.value >= POKEMON_RULES().MAX_LIFE"
[disabled]="foo()" => Angular ne sait pas d'avance ce que cette fonction retourne ni quelles valeurs la fonction utilise en interne donc appelÃ©e Ã  chaque cycle de dÃ©tection de changement

Programmation rÃ©active = Programmation avec des flux
Lorsquâ€™on sâ€™abonne Ã  un flux pour rÃ©cupÃ©rer ses donnÃ©es Ã©ventuelles, on dit que lâ€™on sâ€™abonne au flux.
Dans RxJS, un flux de donnÃ©es est reprÃ©sentÃ© par un objet appelÃ© Observable.
Un observable RxJS est un objet qui permet de produire une sÃ©rie de valeurs asynchrones au

Un Observer est un simple objet JavaScript avec 3 propriÃ©tÃ©s :
next : Une fonction pour traiter les diffÃ©rentes valeurs Ã©mises par lâ€™Observable (un nombre, des tableaux, des objets, etc.)
error : Une fonction pour traiter le cas dâ€™erreur.
complete : Une fonction pour traiter le signal de Â« fin Â».

Par convention, on suffixe les Observables par â€œ$â€
Il faut sâ€™abonner Ã  un Observable et lui passer un Observer en paramÃ¨tre grÃ¢ce Ã  la mÃ©thode subscribe, pour que du code soit rÃ©ellement exÃ©cutÃ©.

const subscription = observable$.subscribe(observer);
subscription.unsubscribe();

un Observable nâ€™est pas quelque chose Ã  usage unique : il continuera dâ€™Ã©mettre des Ã©vÃ©nements jusqu'Ã  ce qu'il Ã©mette une notification dâ€™erreur, de terminaison ou que lâ€™on sâ€™en dÃ©sabonne. Alors quâ€™une promesse ne peut gÃ©rer quâ€™un traitement asynchrone Ã  la fois, et quâ€™une fois en cours, il nâ€™est plus annulableâ€¦

avec par exemple observer = {
  next: (value) => console.log('Je regarde : ' + value),
  error: (err) => console.error('Erreur : ' + err),
  complete: () => console.log('Saison finie !')
}

// Observable = Netflix
const netflix$ = new Observable(subscriber => {
  subscriber.next('Episode 1');
  setTimeout(() => subscriber.next('Episode 2'), 1000);
  setTimeout(() => {
    subscriber.next('Episode 3');
    subscriber.complete();
  }, 2000);
});

// Observer = Vous
const subscription = netflix$.subscribe({
  next: (value) => console.log('Je regarde : ' + value),
  error: (err) => console.error('Erreur : ' + err),
  complete: () => console.log('Saison finie !')
});

// Pensez Ã  vous dÃ©sabonner de Netflix...
// si vous ne regardez plus rien ! ğŸ’¸
subscription.unsubscribe()

utilisation des routes et du module http
export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideHttpClient(),
  ],
};